var searchIndex = JSON.parse('{\
"rust_dgc":{"doc":"","t":[3,13,13,13,13,13,4,4,0,11,11,11,11,11,11,11,11,11,11,14,11,5,11,11,11,12,12,11,12,14,11,11,11,11,11,11,11,11,11,12,11,12,12,12,12,12,12,12,12,3,11,11,11,11,5,5,11,11,11,11,11,11,11],"n":["CwtParsed","Es256","Es256","Rsa","RsaDer","RsaPkcs8","SigningKey","VerificationKey","base45","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","fmt","from","from","from","from_byte_string","get_hcert","get_payload","into","into","into","message","protected_headers","sign","signature","to_byte_string","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","unprotected_headers","verify","d","der","pkcs8","x","y","key","x","y","InvalidCharacter","borrow","borrow_mut","clone","clone_into","decode","encode","fmt","from","into","to_owned","try_from","try_into","type_id"],"q":["rust_dgc","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rust_dgc::SigningKey","","","","","rust_dgc::VerificationKey","","","rust_dgc::base45","","","","","","","","","","","","",""],"d":["The parsed CWT struct","The elliptic curve key, where <code>x</code> and <code>y</code> are byte strings of …","The <code>EC</code> private key","RSA key in the <code>ASN.1</code> encoding as described in RFC-3447 …","The RSA-Private key in the der format without a …","The RSA-Private key in the der format in a PKCS8 …","Possible SigningKeys. We allow <code>RSA</code> or <code>EC</code>.","Possible verification keys. Either <code>RSA</code> or <code>EC</code> ","","","","","","","","","","","","Simple macro to produce a Vec from a byte string.","The <code>hcert</code> is part of the claims in the CWT. The <code>hcert</code> …","Get the CWT payload, which according to RFC-8392 Section-7…","","","","Since we later on want to get the <code>hcert</code> we deserialized …","According to RFC-8152 Section-3  since the protected …","Sign the CWT with the given [SigningKey]. Overwrites the …","The signature as a byte string. In the case of <code>ECDSA</code> this …","Simple macro to produce a byte string from a Vec","","","","","","","","","","Unprotected headers do not need such protection and as …","Verify the signature present in the CWT with the given […","","","","","","","","","","","","","","decode a base45 string to a byte array ignoring unknown …","encode a byte array to base45 according to …","","","","","","",""],"i":[0,1,2,1,2,2,0,0,0,1,2,3,1,2,3,3,1,2,3,0,3,0,1,2,3,3,3,3,3,0,1,2,3,1,2,3,1,2,3,3,3,4,5,6,4,4,7,8,8,0,9,9,9,9,0,0,9,9,9,9,9,9,9],"f":[null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],null,[[],[["option",4],["btreemap",3]]],[[],[["cwtparsed",3],["box",3],["result",4]]],[[]],[[]],[[]],null,null,[[["signingkey",4]],[["result",4],["box",3]]],null,null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,[[["verificationkey",4]],[["result",4],["box",3]]],null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["invalidcharacter",3]],[[]],[[["str",15]],[["invalidcharacter",3],["result",4],["vec",3]]],[[],["string",3]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]]],"p":[[4,"VerificationKey"],[4,"SigningKey"],[3,"CwtParsed"],[13,"Es256"],[13,"RsaDer"],[13,"RsaPkcs8"],[13,"Rsa"],[13,"Es256"],[3,"InvalidCharacter"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};